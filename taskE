#include <iostream>
#include <vector>
#include <list>

struct hash_str {
    size_t operator()(const std::string& s) {
        size_t h = 0;
        for (size_t i = 0; i < s.size() && i < 200; ++i) {
            h += s[i];
            h *= 307;
        }
        return h;
    }
};

template<typename T, typename U, typename hash=std::hash<T>>
class HashTable {
    std::vector<std::list<std::pair<T, U>>> vec;

    typename std::list<std::pair<T, U>>::iterator find(const T& key) {
        size_t hash_code = hash()(key) % vec.size();
        for (auto i = vec[hash_code].begin(); i != vec[hash_code].end(); ++i) if ((*i).first == key) return i;
        return vec[0].end();
    }

public:
    HashTable() {
        vec = std::vector<std::list<std::pair<T, U>>>(1000003);
    }

    explicit HashTable(size_t capacity) {
        vec = std::vector<std::list<std::pair<T, U>>>(capacity);
    }

    std::pair<T, U>& insert(const T& key, const U& value) {
        auto it = find(key);
        if (it == vec[0].end()) {
            vec[hash()(key) % vec.size()].push_front({key, value});
            it = vec[hash()(key) % vec.size()].begin();
        } else (*it).second = value;
        return *it;
    }

    U* get_ptr(const T& key) {
        auto it = find(key);
        if (it == vec[0].end()) return nullptr;
        return &((*it).second);
    }

    void del(const std::string& key) {
        auto it = find(key);
        if (it == vec[0].end()) return;
        vec[hash()(key) % vec.size()].erase(it);
    }

    U& operator[](const T& key) {
        auto it = find(key);
        if (it == vec[0].end()) return insert(key, U()).second;
        return (*it).second;
    }

    void rehash(size_t capacity) {
        std::vector<std::list<std::pair<T, U>>> newVec(capacity);
        for (auto list:vec) for (auto pair:list) newVec[hash()(pair.first)].push_front(pair);
        vec = newVec;
    }
};


int main() {
    freopen("map.in", "r", stdin);
    freopen("map.out", "w", stdout);
    std::ios_base::sync_with_stdio(false);
    std::cin.tie();
    std::cout.tie();

    HashTable<std::string, std::string, hash_str> tab;
    std::string str1, str2, str3;
    while (std::cin >> str1 >> str2) {
        if (str1 == "put") {
            std::cin >> str3;
            tab.insert(str2, str3);
        }
        if (str1 == "get") {
            std::string* ptr = tab.get_ptr(str2);
            if (ptr == nullptr) std::cout << "none" << "\n";
            else std::cout << *ptr << "\n";
        }
        if (str1 == "delete") {
            tab.del(str2);
        }
    }
    return 0;
}
