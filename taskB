#include <iostream>
#include <vector>
#include <list>

template<typename T, typename U, typename hash=std::hash<T>>
class HashTable {
    std::vector<std::list<std::pair<T, U>>> vec;

    typename std::list<std::pair<T, U>>::iterator find(const T& key) {
        size_t hash_code = hash()(key) % vec.size();
        for (auto i = vec[hash_code].begin(); i != vec[hash_code].end(); ++i) if ((*i).first == key) return i;
        return vec[0].end();
    }

public:
    HashTable() {
        vec = std::vector<std::list<std::pair<T, U>>>(1000003);
    }

    explicit HashTable(size_t capacity) {
        vec = std::vector<std::list<std::pair<T, U>>>(capacity);
    }

    std::pair<T, U>& insert(const T& key, const U& value) {
        auto it = find(key);
        if (it == vec[0].end()) {
            vec[hash()(key) % vec.size()].push_front({key, value});
            it = vec[hash()(key) % vec.size()].begin();
        } else (*it).second = value;
        return *it;
    }

    U* get_ptr(const T& key) {
        auto it = find(key);
        if (it == vec[0].end()) return nullptr;
        return &((*it).second);
    }

    void del(const std::string& key) {
        auto it = find(key);
        if (it == vec[0].end()) return;
        vec[hash()(key) % vec.size()].erase(it);
    }

    U& operator[](const T& key) {
        auto it = find(key);
        if (it == vec[0].end()) return insert(key, U()).second;
        return (*it).second;
    }

    void rehash(size_t capacity) {
        std::vector<std::list<std::pair<T, U>>> newVec(capacity);
        for (auto list:vec) for (auto pair:list) newVec[hash()(pair.first)].push_front(pair);
        vec = newVec;
    }
};

int main() {
    std::ios_base::sync_with_stdio(false);
    std::cin.tie();
    std::cout.tie();
    HashTable<int, int> table;
    int n, x, y;
    std::cin >> n;
    for (int i = 0; i < n; ++i) {
        std::cin >> x >> y;
        int* xPtr = table.get_ptr(x);
        int* yPtr = table.get_ptr(y);
        if (xPtr == nullptr) xPtr = &(table.insert(x, x).second);
        if (yPtr == nullptr) yPtr = &(table.insert(y, y).second);
        std::swap(*xPtr, *yPtr);
        std::cout << abs(*xPtr - *yPtr) << "\n";
    }
    return 0;
}
