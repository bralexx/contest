#include <iostream>
#include <queue>
#include <vector>

struct Node {
    std::vector<std::pair<size_t, size_t>> edges;
};

struct AlgoNode {
    std::vector<std::pair<size_t, size_t>> edges;
    bool used = false;
    size_t dist = 1e9;
};

struct Comp {
    bool operator()(const AlgoNode* t1, const AlgoNode* t2) const {
        return t1->dist > t2->dist;
    }
};

std::vector<AlgoNode> dijkstra(const std::vector<Node>& nodes_, size_t start) {
    std::vector<AlgoNode> nodes(nodes_.size());
    for (int i = 0; i < nodes_.size(); ++i) nodes[i].edges = nodes_[i].edges;
    std::priority_queue<AlgoNode*, std::vector<AlgoNode*>, Comp> queue;
    queue.push(&nodes[start]);
    nodes[start].dist = 0;
    while (!queue.empty()) {
        auto top_node = queue.top();
        if (!top_node->used)
            for (auto edge : top_node->edges) {
                nodes[edge.first].dist = std::min(nodes[edge.first].dist, top_node->dist + edge.second);
                queue.push(&nodes[edge.first]);
            }
        top_node->used = true;
        queue.pop();
    }
    return nodes;
}

int main() {
    size_t n, m, start, end;
    std::cin >> n >> m >> start >> end;
    --start;
    --end;
    std::vector<Node> nodes(n);
    for (int i = m; i; --i) {
        size_t s, e, w;
        std::cin >> s >> e >> w;
        --s;
        --e;
        nodes[s].edges.emplace_back(e, w);
        nodes[e].edges.emplace_back(s, w);
    }
    std::vector<AlgoNode> nodes_with_dist = dijkstra(nodes, start);
    if (nodes_with_dist[end].dist == 1e9) std::cout << -1;
    else std::cout << nodes_with_dist[end].dist;
}
