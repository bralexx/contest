#include <iostream>
#include <queue>
#include <vector>

struct Node {
    std::vector<std::pair<Node*, size_t>> edges;
    bool used = false;
    size_t dist = 1e9;
};

struct Comp {
    bool operator()(const Node* t1, const Node* t2) const {
        return t1->dist > t2->dist;
    }
};

std::vector<Node> dijkstra(std::vector<Node>& nodes, size_t start) {
    std::priority_queue<Node*, std::vector<Node*>, Comp> queue;
    queue.push(&nodes[start]);
    nodes[start].dist = 0;
    while (!queue.empty()) {
        auto top_node = queue.top();
        if (!top_node->used)
            for (auto edge : top_node->edges) {
                edge.first->dist = std::min(edge.first->dist, top_node->dist + edge.second);
                queue.push(edge.first);
            }
        top_node->used = true;
        queue.pop();
    }
    return nodes;
}

int main() {
    size_t n, m, start, end;
    std::cin >> n >> m >> start >> end;
    --start;
    --end;
    std::vector<Node> nodes(n);
    for (int i = m; i; --i) {
        size_t s, e, w;
        std::cin >> s >> e >> w;
        --s;
        --e;
        nodes[s].edges.emplace_back(&nodes[e], w);
        nodes[e].edges.emplace_back(&nodes[s], w);
    }
    std::vector<Node> nodes_with_dist = dijkstra(nodes, start);
    if (nodes_with_dist[end].dist == 1e9) std::cout << -1;
    else std::cout << nodes_with_dist[end].dist;
}
